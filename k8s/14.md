## Output of kubectl get po,sts,svc,pvc commands
```bash
.venv➜  app-python git:(lab-14) ✗ kubectl get po,sts,svc,pvc             
NAME                                         READY   STATUS      RESTARTS      AGE
pod/app-go-app-golang-f6c88c544-7fw95        1/1     Running     0             6d17h
pod/app-python-0                             1/1     Running     0             29s
pod/app-python-1                             1/1     Running     0             26s
pod/app-python-post-install-n6xrp            0/1     Completed   0             29s
pod/app-python-pre-install-9nnzf             0/1     Completed   0             54s
pod/app-python-release-7865995874-sj7sm      1/1     Running     4             16h
pod/python-app-app-python-5f4b86cb8d-67ngk   1/1     Running     0             16h
pod/vault-0                                  1/1     Running     5 (26m ago)   6d18h

NAME                          READY   AGE
statefulset.apps/app-python   2/2     29s
statefulset.apps/vault        1/1     7d1h

NAME                               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE
service/app-go-app-golang          ClusterIP   10.101.179.44   <none>        8080/TCP            6d17h
service/app-python                 NodePort    10.100.6.185    <none>        8000:32087/TCP      29s
service/app-python-release         NodePort    10.105.15.120   <none>        8000:32537/TCP      19d
service/helm-hooks-app-python      NodePort    10.99.98.39     <none>        8000:30116/TCP      18d
service/kubernetes                 ClusterIP   10.96.0.1       <none>        443/TCP             19d
service/python-app-app-python      NodePort    10.106.181.21   <none>        8000:31404/TCP      16h
service/vault                      ClusterIP   10.98.120.70    <none>        8200/TCP,8201/TCP   7d1h
service/vault-agent-injector-svc   ClusterIP   10.105.47.76    <none>        443/TCP             7d1h
service/vault-internal             ClusterIP   None            <none>        8200/TCP,8201/TCP   7d1h

NAME                                                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/app-python-pvc-app-python-0   Bound    pvc-a155dcc8-2fc0-43aa-a21f-7c6f521dec49   128Mi      RWO            standard       13m
persistentvolumeclaim/data-volume-app-python-0      Bound    pvc-aeda291c-a87a-4a8d-a2fc-aa06c6be4289   128Mi      RWO            standard       29s
persistentvolumeclaim/data-volume-app-python-1      Bound    pvc-f26f7b1f-5f66-46ea-a122-dd2abc48e6cb   128Mi      RWO            standard       26s
persistentvolumeclaim/name-app-python-0             Bound    pvc-4beb6169-e668-4135-b4ed-9d033fc9cbd0   128Mi      RWO            standard       4m37s
```

## Accesing app

```bash
.venv➜  app-python git:(lab-14) ✗ kubectl exec app-python-1 -- cat data/visits.txt
4                                                                                                                                                                                                                                                                                                            
.venv➜  app-python git:(lab-14) ✗ kubectl exec app-python-0 -- cat data/visits.txt
1
```

Explanation:

Stateful Application: If application maintains state and does not synchronize this state across replicas, each pod could have its own version of the data/visits.txt file.


## Checking volume persistence

```bash
.venv➜  app-python git:(lab-14) ✗ kubectl exec app-python-1 -- cat data/visits.txt 

3%
.venv➜  app-python git:(lab-14) ✗ kubectl delete pod app-python-1      
pod "app-python-1" deleted
.venv➜  app-python git:(lab-14) ✗ kubectl get pvc

NAME                          STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
app-python-pvc-app-python-0   Bound    pvc-a155dcc8-2fc0-43aa-a21f-7c6f521dec49   128Mi      RWO            standard       16m
data-volume-app-python-0      Bound    pvc-aeda291c-a87a-4a8d-a2fc-aa06c6be4289   128Mi      RWO            standard       4m12s
data-volume-app-python-1      Bound    pvc-f26f7b1f-5f66-46ea-a122-dd2abc48e6cb   128Mi      RWO            standard       4m9s
name-app-python-0             Bound    pvc-4beb6169-e668-4135-b4ed-9d033fc9cbd0   128Mi      RWO            standard       8m20s
.venv➜  app-python git:(lab-14) ✗ kubectl exec app-python-1 -- cat /data/visits.txt

3%
```

## DNS resolution
```bash
➜  k8s git:(lab-14) ✗ kubectl exec app-python-0 -- nslookup app-python-1.app-python.default.svc.cluster.local
Server:         10.96.0.10
Address:        10.96.0.10#53

Name:   app-python-1.app-python.svc.cluster.local
Address: 10.244.1.4
```

## Liviness Readiness probes
Liveness and readiness probes are critical components in ensuring that Kubernetes containers are healthy and functioning as expected. These probes periodically check the health of a pod and help Kubernetes determine whether a pod is running properly or needs to be restarted.

1. Liveness Probe: This checks if the container is still running. If the liveness probe fails, Kubernetes restarts the container, assuming that it has entered a non-recoverable state.
2. Readiness Probe: This checks if the container is ready to serve traffic. If the readiness probe fails, Kubernetes stops sending traffic to the pod until the probe passes again.
By adding these probes to your StatefulSet, Kubernetes can automatically handle failed containers by restarting them or removing them from the load balancer pool until they're healthy again.

## Ordering Guarantee and Parallel Operations

In my application, there are no dependencies between the Pods, so they can all be started in parallel. 
This can be easily achieved by setting `podManagementPolicy: Parallel`.

## Updating strategies

OnDelete gives full control over the update process, best for scenarios requiring careful updates.

RollingUpdate automatically updates pods one by one, with partition settings to control how many pods are updated at once.

Deployment Update Strategies differ significantly as StatefulSets handle ordered updates due to their inherent statefulness, while Deployments can be updated in bulk without the need for order.